{"ast":null,"code":"/** pact-lang-api.js\n * Exports functions to support Pact API calls.\n * Author: Will Martino, Hee Kyun Yun, Stuart Popejoy\n * Supports: Pact API 3.0 v1\n */\nconst blake = require(\"blakejs\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst base64url = require(\"base64-url\");\n\nconst fetch = require(\"node-fetch\");\n/**\n * Convert binary to hex.\n * @param s {Uint8Array} - binary value\n * @return {string} hex string\n */\n\n\nvar binToHex = function (s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== \"Uint8Array\") {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n\n  return Buffer.from(s).toString(\"hex\");\n};\n/**\n * Convert hex string to binary.\n * @param s {string} - hex string\n * @return {Uint8Array} binary value\n */\n\n\nvar hexToBin = function (h) {\n  if (typeof h !== \"string\") {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n\n  return new Uint8Array(Buffer.from(h, \"hex\"));\n};\n/**\n * Perform blake2b256 hashing.\n */\n\n\nvar hashBin = function (s) {\n  return blake.blake2b(s, null, 32);\n};\n/**\n * Perform blake2b256 hashing, encoded as unescaped base64url.\n */\n\n\nvar hash = function (s) {\n  return base64UrlEncode(hashBin(s));\n};\n/**\n * Hash string as unescaped base64url.\n */\n\n\nvar base64UrlEncode = function (s) {\n  return base64url.escape(base64url.encode(s));\n};\n/**\n * Generate a random ED25519 keypair.\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\n\n\nvar genKeyPair = function () {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return {\n    publicKey: pubKey,\n    secretKey: secKey\n  };\n};\n/**\n * Generate a deterministic ED25519 keypair from a given Kadena secretKey\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\n\n\nvar restoreKeyPairFromSecretKey = function (seed) {\n  if (!seed) throw new Error(`seed for KeyPair generation not provided`);\n  if (seed.length !== 64) throw new Error('Seed for KeyPair generation has bad size');\n  var seedForNacl = hexToBin(seed);\n  var kp = nacl.sign.keyPair.fromSeed(seedForNacl);\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return {\n    publicKey: pubKey,\n    secretKey: secKey\n  };\n};\n\nvar toTweetNaclSecretKey = function (keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n/**\n * Attach signature to hashed data\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {Array} of \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key values.\n */\n\n\nvar attachSig = function (msg, kpArray) {\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n\n  if (kpArray.length === 0) {\n    return [{\n      hash: hsh,\n      sig: undefined\n    }];\n  } else {\n    return kpArray.map(kp => {\n      if (kp.hasOwnProperty(\"publicKey\") && kp.publicKey && kp.hasOwnProperty(\"secretKey\") && kp.secretKey) {\n        return sign(msg, kp);\n      } else {\n        return {\n          hash: hsh,\n          sig: undefined,\n          publicKey: kp.publicKey\n        };\n      }\n    });\n  }\n};\n/**\n * Sign data using key pair.\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {object} with \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key value.\n */\n\n\nvar sign = function (msg, keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return {\n    hash: hsh,\n    sig: binToHex(sigBin),\n    pubKey: keyPair.publicKey\n  };\n};\n\nvar pullSig = function (s) {\n  if (!s.hasOwnProperty(\"sig\")) {\n    throw new TypeError(\"Expected to find keys of name 'sig' in \" + JSON.stringify(s));\n  }\n\n  return {\n    sig: s.sig\n  };\n};\n\nvar pullAndCheckHashs = function (sigs) {\n  var hsh = sigs[0].hash;\n\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error(\"Sigs for different hashes found: \" + JSON.stringify(sigs));\n    }\n  }\n\n  return hsh;\n};\n/**\n * Prepare an ExecMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param pactCode {string} - pact code to execute - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API command for send or local use.\n */\n\n\nvar prepareExecCmd = function (keyPairs = [], nonce = new Date().toISOString(), pactCode, envData, meta = mkMeta(\"\", \"\", 0, 0, 0, 0), networkId = null) {\n  enforceType(nonce, \"string\", \"nonce\");\n  enforceType(pactCode, \"string\", \"pactCode\");\n  var kpArray = asArray(keyPairs);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      exec: {\n        data: envData || {},\n        code: pactCode\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = attachSig(cmd, kpArray);\n  return mkSingleCmd(sigs, cmd);\n};\n/**\n * Prepare an ContMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param step {number} - integer index of step to execute in defpact body - required\n * @param proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n * @param rollback {bool} - Indicates if this continuation is a rollback/cancel- required\n * @param pactId {string} - identifies the already-begun Pact execution that this is continuing - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API Cont command for send or local use.\n */\n\n\nvar prepareContCmd = function (keyPairs = [], nonce = new Date().toISOString(), proof, pactId, rollback, step, envData, meta = mkMeta(\"\", \"\", 0, 0, 0, 0), networkId = null) {\n  enforceType(nonce, \"string\", \"nonce\");\n  var kpArray = asArray(keyPairs);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      cont: {\n        proof: proof || null,\n        pactId: pactId,\n        rollback: rollback,\n        step: step,\n        data: envData || {}\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = attachSig(cmd, kpArray);\n  return mkSingleCmd(sigs, cmd);\n};\n/**\n * Makes a single command given signed data.\n * @param sigs {array} - array of signature objects, see 'sign'\n * @param cmd {string} - stringified JSON blob used to create hash\n * @return valid Pact API command for send or local use.\n */\n\n\nvar mkSingleCmd = function (sigs, cmd) {\n  enforceArray(sigs, \"sigs\");\n  enforceType(cmd, \"string\", \"cmd\");\n  return {\n    hash: pullAndCheckHashs(sigs),\n    sigs: sigs.filter(sig => sig.sig).map(pullSig),\n    cmd: cmd\n  };\n};\n/**\n * Makes outer wrapper for a 'send' endpoint.\n * @param {array or object} cmds - one or an array of commands, see mkSingleCmd\n */\n\n\nvar mkPublicSend = function (cmds) {\n  return {\n    cmds: asArray(cmds)\n  };\n};\n/**\n * Make an ED25519 \"signer\" array element for inclusion in a Pact payload.\n * @param {object} kp - a ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @return {object} an object with pubKey, addr and scheme fields.\n */\n\n\nvar mkSigner = function (kp) {\n  if (kp.clist) {\n    return {\n      clist: asArray(kp.clist),\n      pubKey: kp.publicKey\n    };\n  } else {\n    return {\n      pubKey: kp.publicKey\n    };\n  }\n};\n\nvar asArray = function (singleOrArray) {\n  if (Array.isArray(singleOrArray)) {\n    return singleOrArray;\n  } else {\n    return [singleOrArray];\n  }\n};\n\nvar enforceType = function (val, type, msg) {\n  if (typeof val !== type) {\n    throw new TypeError(msg + \" must be a \" + type + \": \" + JSON.stringify(val));\n  }\n};\n\nvar enforceArray = function (val, msg) {\n  if (!Array.isArray(val)) {\n    throw new TypeError(msg + \" must be an array: \" + JSON.stringify(val));\n  }\n};\n/**\n * Make a full 'send' endpoint exec command. See 'prepareExecCmd' for parameters.\n */\n\n\nvar simpleExecCommand = function (keyPairs, nonce, pactCode, envData, meta, networkId) {\n  return mkPublicSend(prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId));\n};\n/**\n * Make a full 'send' endpoint cont command. See 'prepareContCmd' for parameters.\n */\n\n\nvar simpleContCommand = function (keyPairs, nonce, step, pactId, rollback, envData, meta, proof, networkId) {\n  return mkPublicSend(prepareContCmd(keyPairs, nonce, proof, pactId, rollback, step, envData, meta, networkId));\n};\n\nvar unique = function (arr) {\n  var n = {},\n      r = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n\n  return r;\n};\n/**\n * Given an exec 'send' message, prepare a message for 'poll' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'\n * @return {object} with \"requestKeys\" for polling.\n */\n\n\nvar simplePollRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    requestKeys: rks\n  };\n};\n/**\n * Given an exec 'send' message, prepare a message for 'listen' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'. Only takes first element.\n * @return {object} with \"requestKey\" for polling.\n */\n\n\nvar simpleListenRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    listen: rks[0]\n  };\n};\n/**\n * Variadic function to form a lisp s-expression application.\n * Encases arguments in parens and intercalates with a space.\n */\n\n\nvar mkExp = function (pgmName) {\n  enforceType(pgmName, \"string\", \"pgmName\");\n  return \"(\" + pgmName + \" \" + Array.prototype.slice.call(arguments, 1).map(JSON.stringify).join(\" \") + \")\";\n};\n/**\n * Prepare a chainweb-style public meta payload.\n * @param sender {string} gas account\n * @param chainId {string} chain identifier\n * @param gasPrice {number} desired gas price\n * @param gasLimit {number} desired gas limit\n * @param creationTime {number} desired tx's time created in UNIX epoch time as seconds\n * @param ttl {number} desired tx's time to live as seconds\n * @return {object} of arguments, type-checked and properly named.\n */\n\n\nvar mkMeta = function (sender, chainId, gasPrice, gasLimit, creationTime, ttl) {\n  enforceType(sender, \"string\", \"sender\");\n  enforceType(chainId, \"string\", \"chainId\");\n  enforceType(gasPrice, \"number\", \"gasPrice\");\n  enforceType(gasLimit, \"number\", \"gasLimit\");\n  enforceType(creationTime, \"number\", \"creationTime\");\n  enforceType(ttl, \"number\", \"ttl\");\n  return {\n    creationTime: creationTime,\n    ttl: ttl,\n    gasLimit: gasLimit,\n    chainId: chainId,\n    gasPrice: gasPrice,\n    sender: sender\n  };\n};\n/**\n * Formats ExecCmd into api request object\n */\n\n\nvar mkReq = function (cmd) {\n  return {\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    body: JSON.stringify(cmd)\n  };\n};\n/**\n * Parses raw response from server into JSON or TEXT\n */\n\n\nvar parseRes = async function (raw) {\n  const rawRes = await raw;\n  const res = await rawRes;\n\n  if (res.ok) {\n    const resJSON = await rawRes.json();\n    return resJSON;\n  } else {\n    const resTEXT = await rawRes.text();\n    return resTEXT;\n  }\n};\n/**\n * An execCmd Object to Execute in send or local.\n * @typedef {Object} cmd to `/send` endpoint\n * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n * @property pactCode {string} - pact code to execute in \"exec\" command - required for \"exec\"\n * @property nonce {string} - nonce value to ensure unique hash - default to current time\n * @property envData {object} - JSON of data in command - not required\n * @property meta {object} - public meta information, see mkMeta\n * @property networkId {object} network identifier of where the cmd is executed.\n */\n\n/**\n * A contCmd to Execute in send\n * @typedef {Object} cmd to `/send` endpoint\n * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n * @property pactId {string} - pactId the cont command - required for \"cont\"\n * @property nonce {string} - nonce value to ensure unique hash - default to current time\n * @property step {number} - the step of the mutli-step transaction - required for \"cont\"\n * @property proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n * @property rollback {bool} - Indicates if this continuation is a rollback/cancel - required for \"cont\"\n * @property envData {object} - JSON of data in command - not required\n * @property meta {object} - public meta information, see mkMeta\n * @property networkId {object} network identifier of where the cmd is executed.\n */\n\n/**\n* Sends Pact command to a running Pact server and retrieves tx result.\n* @param {[execCmd or contCmd] or execCmd or contCmd} cmd or a list of cmds to execute\n* @param {string} apiHost host running Pact server\n* @return {object} Request key of the tx received from pact server.\n*/\n\n\nconst fetchSend = async function (sendCmd, apiHost) {\n  let res = fetchSendRaw(sendCmd, apiHost);\n  return parseRes(res);\n};\n/**\n* Sends Pact command to a running Pact server and retrieves raw response.\n* @param {[execCmd or contCmd] or execCmd or contCmd} cmd or a list of cmds to execute\n* @param {string} apiHost host running Pact server\n* @return {Promise} Raw Response from Pact Server\n*/\n\n\nconst fetchSendRaw = function (sendCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.send(): No apiHost provided`);\n  const sendCmds = asArray(sendCmd).map(cmd => {\n    if (cmd.type === \"cont\") {\n      return prepareContCmd(cmd.keyPairs, cmd.nonce, cmd.proof, cmd.pactId, cmd.rollback, cmd.step, cmd.envData, cmd.meta, cmd.networkId);\n    } else {\n      return prepareExecCmd(cmd.keyPairs, cmd.nonce, cmd.pactCode, cmd.envData, cmd.meta, cmd.networkId);\n    }\n  });\n  return fetch(`${apiHost}/api/v1/send`, mkReq(mkPublicSend(sendCmds)));\n};\n/**\n * A SPV Command Object to Execute in Pact Server.\n * @typedef {Object} spvCmd\n * @property requestKey {string} pactId of the cross-chain transaction\n * @property targetChainId {string} chainId of target chain of the cross-chain transaction\n */\n\n/**\n * Sends request to /spv and retrieves SPV proof.\n * @param {spvCmd} spvCmd see spvCmd\n * @param {string} apiHost host running Pact server\n * @return {string} SPV proof received from Pact server.\n */\n\n\nconst fetchSPV = async function (spvCmd, apiHost) {\n  let res = fetchSPVRaw(spvCmd, apiHost);\n  return parseRes(res);\n};\n/**\n * Sends request to /spv and retrieves raw response.\n * @param {spvCmd} spvCmd see spvCmd\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\n\nconst fetchSPVRaw = function (spvCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.spv(): No apiHost provided`);\n  enforceType(spvCmd.targetChainId, \"string\", \"targetChainId\");\n  enforceType(spvCmd.requestKey, \"string\", \"requestKey\");\n  return fetch(`${apiHost}/spv`, mkReq(spvCmd));\n};\n/**\n * Sends Local Pact command to a local Pact server and retrieves local tx result.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {object} tx result received from pact server.\n */\n\n\nconst fetchLocal = async function (localCmd, apiHost) {\n  let res = fetchLocalRaw(localCmd, apiHost);\n  return parseRes(res);\n};\n/**\n * Sends Local Pact command to a local Pact server and retrieves raw response.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\n\nconst fetchLocalRaw = function (localCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.local(): No apiHost provided`);\n  const {\n    keyPairs,\n    nonce,\n    pactCode,\n    envData,\n    meta,\n    networkId\n  } = localCmd;\n  const cmd = prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId);\n  return fetch(`${apiHost}/api/v1/local`, mkReq(cmd));\n};\n/**\n * Poll result of Pact command on a Pact server and retrieve tx result.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {object} Array of tx request keys and tx results from pact server.\n */\n\n\nconst fetchPoll = async function (pollCmd, apiHost) {\n  let res = fetchPollRaw(pollCmd, apiHost);\n  return parseRes(res);\n};\n/**\n * Poll result of Pact command on a Pact server and retrieves raw response.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\n\nconst fetchPollRaw = function (pollCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.poll(): No apiHost provided`);\n  return fetch(`${apiHost}/api/v1/poll`, mkReq(pollCmd));\n};\n/**\n * Listen for result of Pact command on a Pact server and retrieve tx result.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {object} Object containing tx result from pact server\n */\n\n\nconst fetchListen = async function (listenCmd, apiHost) {\n  let res = fetchListenRaw(listenCmd, apiHost);\n  return parseRes(res);\n};\n/**\n * Listen for result of Pact command on a Pact server and retrieves raw response.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\n\nconst fetchListenRaw = function (listenCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.listen(): No apiHost provided`);\n  return fetch(`${apiHost}/api/v1/listen`, mkReq(listenCmd));\n};\n/**\n  Signing API functions to interact with Chainweaver wallet (https://github.com/kadena-io/chainweaver) and its signing API.\n */\n\n/**\n * Prepares a capability object to be signed with keyPairs using signing API.\n * @param role {string} role of the pact capability\n * @param description {string} description of the pact capability\n * @param name {string} name of pact capability to be signed\n * @param args {array} array of arguments used in pact capability, default to empty array.\n * @return {object} A properly formatted cap object required in signingCmd\n */\n\n\nvar mkCap = function (role, description, name, args = []) {\n  enforceType(role, \"string\", \"role\");\n  enforceType(description, \"string\", \"description\");\n  enforceType(name, \"string\", \"name of capability\");\n  enforceType(args, \"object\", \"arguments to capability\");\n  return {\n    role: role,\n    description: description,\n    cap: {\n      name: name,\n      args: args\n    }\n  };\n};\n/**\n * A signingCmd Object to send to signing API\n * @typedef {Object} signingCmd - cmd to send to signing API\n * @property pactCode {string} - Pact code to execute - required\n * @property caps {array or object} - Pact capability to be signed, see mkCap - required\n * @property envData {object} - JSON of data in command - optional\n * @property sender {string} - sender field in meta, see mkMeta - optional\n * @property chainId {string} - chainId field in meta, see mkMeta - optional\n * @property gasLimit {number} - gasLimit field in meta, see mkMeta - optional\n * @property nonce {string} - nonce value for ensuring unique hash - optional\n **/\n\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves a signed Pact Command.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n\n\nconst signWallet = async function (signingCmd) {\n  let res = signWalletRaw(signingCmd);\n  let resParsed = await parseRes(res);\n  return resParsed.body;\n};\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves raw response.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n\n\nconst signWalletRaw = function (signingCmd) {\n  if (!signingCmd.pactCode) throw new Error(`Pact.wallet.sign(): No Pact Code provided`);\n  if (!signingCmd.caps) throw new Error(`Pact.wallet.sign(): No Caps provided`);\n  enforceType(signingCmd.pactCode, \"string\", \"pactCode\");\n  enforceType(signingCmd.caps, \"object\", \"caps\");\n  if (signingCmd.envData) enforceType(signingCmd.envData, \"object\", \"envData\");\n  if (signingCmd.sender) enforceType(signingCmd.sender, \"string\", \"sender\");\n  if (signingCmd.chainId) enforceType(signingCmd.chainId, \"string\", \"chainId\");\n  if (signingCmd.gasLimit) enforceType(signingCmd.gasLimit, \"number\", \"gasLimit\");\n  if (signingCmd.nonce) enforceType(signingCmd.nonce, \"string\", \"nonce\");\n  if (signingCmd.ttl) enforceType(signingCmd.ttl, \"number\", \"ttl\");\n  const cmd = {\n    code: signingCmd.pactCode,\n    caps: asArray(signingCmd.caps),\n    data: signingCmd.envData,\n    sender: signingCmd.sender,\n    chainId: signingCmd.chainId,\n    gasLimit: signingCmd.gasLimit,\n    nonce: signingCmd.nonce,\n    ttl: signingCmd.ttl\n  };\n  return fetch('http://127.0.0.1:9467/v1/sign', mkReq(cmd));\n};\n/**\n * Sends a signed Pact ExecCmd to a running Pact server and retrieves tx result.\n * @param {signedCmd} valid pact API command for send or local use.\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\n\n\nconst sendSigned = async function (signedCmd, apiHost) {\n  const cmd = {\n    \"cmds\": [signedCmd]\n  };\n  const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n};\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    base64UrlEncode: base64UrlEncode,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    restoreKeyPairFromSecretKey: restoreKeyPairFromSecretKey,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    prepareContCmd: prepareContCmd,\n    prepareExecCmd: prepareExecCmd,\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp,\n    mkMeta: mkMeta,\n    mkCap: mkCap\n  },\n  simple: {\n    cont: {\n      createCommand: simpleContCommand\n    },\n    exec: {\n      createCommand: simpleExecCommand,\n      createLocalCommand: prepareExecCmd,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  },\n  fetch: {\n    send: fetchSend,\n    local: fetchLocal,\n    poll: fetchPoll,\n    listen: fetchListen,\n    spv: fetchSPV\n  },\n  wallet: {\n    sign: signWallet,\n    sendSigned: sendSigned\n  }\n};","map":{"version":3,"sources":["/Users/francescomelpignano/Desktop/kadena/code/cpa/templates/react/node_modules/pact-lang-api/pact-lang-api.js"],"names":["blake","require","nacl","base64url","fetch","binToHex","s","constructor","name","TypeError","Buffer","from","toString","hexToBin","h","Uint8Array","hashBin","blake2b","hash","base64UrlEncode","escape","encode","genKeyPair","kp","sign","keyPair","pubKey","publicKey","secKey","secretKey","slice","restoreKeyPairFromSecretKey","seed","Error","length","seedForNacl","fromSeed","toTweetNaclSecretKey","hasOwnProperty","JSON","stringify","attachSig","msg","kpArray","hshBin","hsh","sig","undefined","map","sigBin","detached","pullSig","pullAndCheckHashs","sigs","i","prepareExecCmd","keyPairs","nonce","Date","toISOString","pactCode","envData","meta","mkMeta","networkId","enforceType","asArray","signers","mkSigner","cmdJSON","payload","exec","data","code","cmd","mkSingleCmd","prepareContCmd","proof","pactId","rollback","step","cont","enforceArray","filter","mkPublicSend","cmds","clist","singleOrArray","Array","isArray","val","type","simpleExecCommand","simpleContCommand","unique","arr","n","r","push","simplePollRequestFromExec","execMsg","rks","every","v","requestKeys","simpleListenRequestFromExec","listen","mkExp","pgmName","prototype","call","arguments","join","sender","chainId","gasPrice","gasLimit","creationTime","ttl","mkReq","headers","method","body","parseRes","raw","rawRes","res","ok","resJSON","json","resTEXT","text","fetchSend","sendCmd","apiHost","fetchSendRaw","sendCmds","fetchSPV","spvCmd","fetchSPVRaw","targetChainId","requestKey","fetchLocal","localCmd","fetchLocalRaw","fetchPoll","pollCmd","fetchPollRaw","fetchListen","listenCmd","fetchListenRaw","mkCap","role","description","args","cap","signWallet","signingCmd","signWalletRaw","resParsed","caps","sendSigned","signedCmd","txRes","tx","module","exports","crypto","api","lang","simple","createCommand","createLocalCommand","createPollRequest","createListenRequest","send","local","poll","spv","wallet"],"mappings":"AAAA;;;;;AAMA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,WAAD,CAApB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,YAAD,CAAzB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,YAAD,CAArB;AAEA;;;;;;;AAKA,IAAII,QAAQ,GAAG,UAASC,CAAT,EAAY;AACzB,MAAIC,WAAW,GAAGD,CAAC,CAACC,WAAF,CAAcC,IAAd,IAAsB,IAAxC;;AAEA,MAAID,WAAW,KAAK,YAApB,EAAkC;AAChC,UAAM,IAAIE,SAAJ,CAAc,qBAAd,CAAN;AACD;;AAED,SAAOC,MAAM,CAACC,IAAP,CAAYL,CAAZ,EAAeM,QAAf,CAAwB,KAAxB,CAAP;AACD,CARD;AAUA;;;;;;;AAKA,IAAIC,QAAQ,GAAG,UAASC,CAAT,EAAY;AACzB,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACzB,UAAM,IAAIL,SAAJ,CAAc,sBAAsBK,CAApC,CAAN;AACD;;AACD,SAAO,IAAIC,UAAJ,CAAeL,MAAM,CAACC,IAAP,CAAYG,CAAZ,EAAe,KAAf,CAAf,CAAP;AACD,CALD;AAOA;;;;;AAGA,IAAIE,OAAO,GAAG,UAASV,CAAT,EAAY;AACxB,SAAON,KAAK,CAACiB,OAAN,CAAcX,CAAd,EAAiB,IAAjB,EAAuB,EAAvB,CAAP;AACD,CAFD;AAIA;;;;;AAGA,IAAIY,IAAI,GAAG,UAASZ,CAAT,EAAY;AACrB,SAAOa,eAAe,CAACH,OAAO,CAACV,CAAD,CAAR,CAAtB;AACD,CAFD;AAIA;;;;;AAGA,IAAIa,eAAe,GAAG,UAASb,CAAT,EAAY;AAChC,SAAOH,SAAS,CAACiB,MAAV,CAAiBjB,SAAS,CAACkB,MAAV,CAAiBf,CAAjB,CAAjB,CAAP;AACD,CAFD;AAIA;;;;;;AAIA,IAAIgB,UAAU,GAAG,YAAW;AAC1B,MAAIC,EAAE,GAAGrB,IAAI,CAACsB,IAAL,CAAUC,OAAV,EAAT;AACA,MAAIC,MAAM,GAAGrB,QAAQ,CAACkB,EAAE,CAACI,SAAJ,CAArB;AACA,MAAIC,MAAM,GAAGvB,QAAQ,CAACkB,EAAE,CAACM,SAAJ,CAAR,CAAuBC,KAAvB,CAA6B,CAA7B,EAAgC,EAAhC,CAAb;AACA,SAAO;AAAEH,IAAAA,SAAS,EAAED,MAAb;AAAqBG,IAAAA,SAAS,EAAED;AAAhC,GAAP;AACD,CALD;AAOA;;;;;;AAIA,IAAIG,2BAA2B,GAAG,UAASC,IAAT,EAAe;AAC/C,MAAI,CAACA,IAAL,EAAY,MAAM,IAAIC,KAAJ,CAAW,0CAAX,CAAN;AACZ,MAAID,IAAI,CAACE,MAAL,KAAgB,EAApB,EAAwB,MAAM,IAAID,KAAJ,CAAU,0CAAV,CAAN;AACxB,MAAIE,WAAW,GAAGtB,QAAQ,CAACmB,IAAD,CAA1B;AACA,MAAIT,EAAE,GAAGrB,IAAI,CAACsB,IAAL,CAAUC,OAAV,CAAkBW,QAAlB,CAA2BD,WAA3B,CAAT;AACA,MAAIT,MAAM,GAAGrB,QAAQ,CAACkB,EAAE,CAACI,SAAJ,CAArB;AACA,MAAIC,MAAM,GAAGvB,QAAQ,CAACkB,EAAE,CAACM,SAAJ,CAAR,CAAuBC,KAAvB,CAA6B,CAA7B,EAAgC,EAAhC,CAAb;AACA,SAAO;AAAEH,IAAAA,SAAS,EAAED,MAAb;AAAqBG,IAAAA,SAAS,EAAED;AAAhC,GAAP;AACD,CARD;;AAUA,IAAIS,oBAAoB,GAAG,UAASZ,OAAT,EAAkB;AAC3C,MACE,CAACA,OAAO,CAACa,cAAR,CAAuB,WAAvB,CAAD,IACA,CAACb,OAAO,CAACa,cAAR,CAAuB,WAAvB,CAFH,EAGE;AACA,UAAM,IAAI7B,SAAJ,CACJ,iFACE8B,IAAI,CAACC,SAAL,CAAef,OAAf,CAFE,CAAN;AAID;;AACD,SAAOZ,QAAQ,CAACY,OAAO,CAACI,SAAR,GAAoBJ,OAAO,CAACE,SAA7B,CAAf;AACD,CAXD;AAaA;;;;;;;;AAMA,IAAIc,SAAS,GAAG,UAASC,GAAT,EAAcC,OAAd,EAAuB;AACrC,MAAIC,MAAM,GAAG5B,OAAO,CAAC0B,GAAD,CAApB;AACA,MAAIG,GAAG,GAAG1B,eAAe,CAACyB,MAAD,CAAzB;;AACA,MAAID,OAAO,CAACT,MAAR,KAAmB,CAAvB,EAA2B;AAC1B,WAAO,CAAC;AAAChB,MAAAA,IAAI,EAAE2B,GAAP;AAAYC,MAAAA,GAAG,EAAEC;AAAjB,KAAD,CAAP;AACA,GAFD,MAEO;AACL,WAAOJ,OAAO,CAACK,GAAR,CAAYzB,EAAE,IAAI;AACvB,UACGA,EAAE,CAACe,cAAH,CAAkB,WAAlB,KAAkCf,EAAE,CAACI,SAAtC,IACCJ,EAAE,CAACe,cAAH,CAAkB,WAAlB,KAAkCf,EAAE,CAACM,SAFxC,EAEoD;AAClD,eAAOL,IAAI,CAACkB,GAAD,EAAMnB,EAAN,CAAX;AACD,OAJD,MAIO;AACL,eAAO;AACLL,UAAAA,IAAI,EAAE2B,GADD;AAELC,UAAAA,GAAG,EAAEC,SAFA;AAGLpB,UAAAA,SAAS,EAAEJ,EAAE,CAACI;AAHT,SAAP;AAKD;AACF,KAZM,CAAP;AAaD;AACF,CApBD;AAsBA;;;;;;;;AAMA,IAAIH,IAAI,GAAG,UAASkB,GAAT,EAAcjB,OAAd,EAAuB;AAChC,MACE,CAACA,OAAO,CAACa,cAAR,CAAuB,WAAvB,CAAD,IACA,CAACb,OAAO,CAACa,cAAR,CAAuB,WAAvB,CAFH,EAGE;AACA,UAAM,IAAI7B,SAAJ,CACJ,iFACE8B,IAAI,CAACC,SAAL,CAAef,OAAf,CAFE,CAAN;AAID;;AACD,MAAImB,MAAM,GAAG5B,OAAO,CAAC0B,GAAD,CAApB;AACA,MAAIG,GAAG,GAAG1B,eAAe,CAACyB,MAAD,CAAzB;AACA,MAAIK,MAAM,GAAG/C,IAAI,CAACsB,IAAL,CAAU0B,QAAV,CAAmBN,MAAnB,EAA2BP,oBAAoB,CAACZ,OAAD,CAA/C,CAAb;AACA,SAAO;AAAEP,IAAAA,IAAI,EAAE2B,GAAR;AAAaC,IAAAA,GAAG,EAAEzC,QAAQ,CAAC4C,MAAD,CAA1B;AAAoCvB,IAAAA,MAAM,EAAED,OAAO,CAACE;AAApD,GAAP;AACD,CAdD;;AAgBA,IAAIwB,OAAO,GAAG,UAAS7C,CAAT,EAAY;AACxB,MAAI,CAACA,CAAC,CAACgC,cAAF,CAAiB,KAAjB,CAAL,EAA8B;AAC5B,UAAM,IAAI7B,SAAJ,CACJ,4CAA4C8B,IAAI,CAACC,SAAL,CAAelC,CAAf,CADxC,CAAN;AAGD;;AACD,SAAO;AAAEwC,IAAAA,GAAG,EAAExC,CAAC,CAACwC;AAAT,GAAP;AACD,CAPD;;AASA,IAAIM,iBAAiB,GAAG,UAASC,IAAT,EAAe;AACrC,MAAIR,GAAG,GAAGQ,IAAI,CAAC,CAAD,CAAJ,CAAQnC,IAAlB;;AACA,OAAK,IAAIoC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAAI,CAACnB,MAAzB,EAAiCoB,CAAC,EAAlC,EAAsC;AACpC,QAAID,IAAI,CAACC,CAAD,CAAJ,CAAQpC,IAAR,KAAiB2B,GAArB,EAA0B;AACxB,YAAM,IAAIZ,KAAJ,CACJ,sCAAsCM,IAAI,CAACC,SAAL,CAAea,IAAf,CADlC,CAAN;AAGD;AACF;;AACD,SAAOR,GAAP;AACD,CAVD;AAYA;;;;;;;;;;;;AAUA,IAAIU,cAAc,GAAG,UAASC,QAAQ,GAAC,EAAlB,EAAsBC,KAAK,GAAC,IAAIC,IAAJ,GAAWC,WAAX,EAA5B,EAAsDC,QAAtD,EACSC,OADT,EACkBC,IAAI,GAACC,MAAM,CAAC,EAAD,EAAI,EAAJ,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,CAD7B,EAC8CC,SAAS,GAAC,IADxD,EAC8D;AAEjFC,EAAAA,WAAW,CAACR,KAAD,EAAQ,QAAR,EAAkB,OAAlB,CAAX;AACAQ,EAAAA,WAAW,CAACL,QAAD,EAAW,QAAX,EAAqB,UAArB,CAAX;AACA,MAAIjB,OAAO,GAAGuB,OAAO,CAACV,QAAD,CAArB;AACA,MAAIW,OAAO,GAAGxB,OAAO,CAACK,GAAR,CAAYoB,QAAZ,CAAd;AACA,MAAIC,OAAO,GAAG;AACZL,IAAAA,SAAS,EAAEA,SADC;AAEZM,IAAAA,OAAO,EAAE;AACPC,MAAAA,IAAI,EAAE;AACJC,QAAAA,IAAI,EAAEX,OAAO,IAAI,EADb;AAEJY,QAAAA,IAAI,EAAEb;AAFF;AADC,KAFG;AAQZO,IAAAA,OAAO,EAAEA,OARG;AASZL,IAAAA,IAAI,EAAEA,IATM;AAUZL,IAAAA,KAAK,EAAElB,IAAI,CAACC,SAAL,CAAeiB,KAAf;AAVK,GAAd;AAYA,MAAIiB,GAAG,GAAGnC,IAAI,CAACC,SAAL,CAAe6B,OAAf,CAAV;AACA,MAAIhB,IAAI,GAAGZ,SAAS,CAACiC,GAAD,EAAM/B,OAAN,CAApB;AACA,SAAOgC,WAAW,CAACtB,IAAD,EAAOqB,GAAP,CAAlB;AACD,CAtBD;AAwBA;;;;;;;;;;;;;;;AAaA,IAAIE,cAAc,GAAG,UAASpB,QAAQ,GAAC,EAAlB,EAAsBC,KAAK,GAAC,IAAIC,IAAJ,GAAWC,WAAX,EAA5B,EACSkB,KADT,EACgBC,MADhB,EACwBC,QADxB,EACkCC,IADlC,EACwCnB,OADxC,EAESC,IAAI,GAACC,MAAM,CAAC,EAAD,EAAI,EAAJ,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,CAFpB,EAEqCC,SAAS,GAAC,IAF/C,EAEqD;AAExEC,EAAAA,WAAW,CAACR,KAAD,EAAQ,QAAR,EAAkB,OAAlB,CAAX;AACA,MAAId,OAAO,GAAGuB,OAAO,CAACV,QAAD,CAArB;AACA,MAAIW,OAAO,GAAGxB,OAAO,CAACK,GAAR,CAAYoB,QAAZ,CAAd;AACA,MAAIC,OAAO,GAAG;AACZL,IAAAA,SAAS,EAAEA,SADC;AAEZM,IAAAA,OAAO,EAAE;AACPW,MAAAA,IAAI,EAAE;AACJJ,QAAAA,KAAK,EAAEA,KAAK,IAAI,IADZ;AAEJC,QAAAA,MAAM,EAAEA,MAFJ;AAGJC,QAAAA,QAAQ,EAAEA,QAHN;AAIJC,QAAAA,IAAI,EAAEA,IAJF;AAKJR,QAAAA,IAAI,EAAEX,OAAO,IAAI;AALb;AADC,KAFG;AAWZM,IAAAA,OAAO,EAAEA,OAXG;AAYZL,IAAAA,IAAI,EAAEA,IAZM;AAaZL,IAAAA,KAAK,EAAElB,IAAI,CAACC,SAAL,CAAeiB,KAAf;AAbK,GAAd;AAeA,MAAIiB,GAAG,GAAGnC,IAAI,CAACC,SAAL,CAAe6B,OAAf,CAAV;AACA,MAAIhB,IAAI,GAAGZ,SAAS,CAACiC,GAAD,EAAM/B,OAAN,CAApB;AACA,SAAOgC,WAAW,CAACtB,IAAD,EAAOqB,GAAP,CAAlB;AACD,CAzBD;AA2BA;;;;;;;;AAMA,IAAIC,WAAW,GAAG,UAAStB,IAAT,EAAeqB,GAAf,EAAoB;AACpCQ,EAAAA,YAAY,CAAC7B,IAAD,EAAO,MAAP,CAAZ;AACAY,EAAAA,WAAW,CAACS,GAAD,EAAM,QAAN,EAAgB,KAAhB,CAAX;AACA,SAAO;AACLxD,IAAAA,IAAI,EAAEkC,iBAAiB,CAACC,IAAD,CADlB;AAELA,IAAAA,IAAI,EAAEA,IAAI,CAAC8B,MAAL,CAAYrC,GAAG,IAAIA,GAAG,CAACA,GAAvB,EAA4BE,GAA5B,CAAgCG,OAAhC,CAFD;AAGLuB,IAAAA,GAAG,EAAEA;AAHA,GAAP;AAKD,CARD;AAUA;;;;;;AAIA,IAAIU,YAAY,GAAG,UAASC,IAAT,EAAe;AAChC,SAAO;AAAEA,IAAAA,IAAI,EAAEnB,OAAO,CAACmB,IAAD;AAAf,GAAP;AACD,CAFD;AAIA;;;;;;;AAKA,IAAIjB,QAAQ,GAAG,UAAS7C,EAAT,EAAa;AAC1B,MAAIA,EAAE,CAAC+D,KAAP,EAAc;AACZ,WAAO;AACLA,MAAAA,KAAK,EAAEpB,OAAO,CAAC3C,EAAE,CAAC+D,KAAJ,CADT;AAEL5D,MAAAA,MAAM,EAAEH,EAAE,CAACI;AAFN,KAAP;AAID,GALD,MAKO;AACL,WAAO;AAACD,MAAAA,MAAM,EAAEH,EAAE,CAACI;AAAZ,KAAP;AACD;AACF,CATD;;AAWA,IAAIuC,OAAO,GAAG,UAASqB,aAAT,EAAwB;AACpC,MAAIC,KAAK,CAACC,OAAN,CAAcF,aAAd,CAAJ,EAAkC;AAChC,WAAOA,aAAP;AACD,GAFD,MAEO;AACL,WAAO,CAACA,aAAD,CAAP;AACD;AACF,CAND;;AAQA,IAAItB,WAAW,GAAG,UAASyB,GAAT,EAAcC,IAAd,EAAoBjD,GAApB,EAAyB;AACzC,MAAI,OAAOgD,GAAP,KAAeC,IAAnB,EAAyB;AACvB,UAAM,IAAIlF,SAAJ,CACJiC,GAAG,GAAG,aAAN,GAAsBiD,IAAtB,GAA6B,IAA7B,GAAoCpD,IAAI,CAACC,SAAL,CAAekD,GAAf,CADhC,CAAN;AAGD;AACF,CAND;;AAQA,IAAIR,YAAY,GAAG,UAASQ,GAAT,EAAchD,GAAd,EAAmB;AACpC,MAAI,CAAC8C,KAAK,CAACC,OAAN,CAAcC,GAAd,CAAL,EAAyB;AACvB,UAAM,IAAIjF,SAAJ,CAAciC,GAAG,GAAG,qBAAN,GAA8BH,IAAI,CAACC,SAAL,CAAekD,GAAf,CAA5C,CAAN;AACD;AACF,CAJD;AAMA;;;;;AAGA,IAAIE,iBAAiB,GAAG,UAASpC,QAAT,EAAmBC,KAAnB,EAA0BG,QAA1B,EAAoCC,OAApC,EAA6CC,IAA7C,EAAmDE,SAAnD,EAA8D;AACpF,SAAOoB,YAAY,CAAC7B,cAAc,CAACC,QAAD,EAAWC,KAAX,EAAkBG,QAAlB,EAA4BC,OAA5B,EAAqCC,IAArC,EAA2CE,SAA3C,CAAf,CAAnB;AACD,CAFD;AAIA;;;;;AAGA,IAAI6B,iBAAiB,GAAG,UAASrC,QAAT,EAAmBC,KAAnB,EAA0BuB,IAA1B,EAAgCF,MAAhC,EAAwCC,QAAxC,EAAkDlB,OAAlD,EAA2DC,IAA3D,EAAiEe,KAAjE,EAAwEb,SAAxE,EAAmF;AACzG,SAAOoB,YAAY,CAACR,cAAc,CAACpB,QAAD,EAAWC,KAAX,EAAkBoB,KAAlB,EAAyBC,MAAzB,EAAiCC,QAAjC,EAA2CC,IAA3C,EAAiDnB,OAAjD,EAA0DC,IAA1D,EAAgEE,SAAhE,CAAf,CAAnB;AACD,CAFD;;AAIA,IAAI8B,MAAM,GAAG,UAASC,GAAT,EAAc;AACzB,MAAIC,CAAC,GAAG,EAAR;AAAA,MACEC,CAAC,GAAG,EADN;;AAEA,OAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,GAAG,CAAC7D,MAAxB,EAAgCoB,CAAC,EAAjC,EAAqC;AACnC,QAAI,CAAC0C,CAAC,CAACD,GAAG,CAACzC,CAAD,CAAJ,CAAN,EAAgB;AACd0C,MAAAA,CAAC,CAACD,GAAG,CAACzC,CAAD,CAAJ,CAAD,GAAY,IAAZ;AACA2C,MAAAA,CAAC,CAACC,IAAF,CAAOH,GAAG,CAACzC,CAAD,CAAV;AACD;AACF;;AACD,SAAO2C,CAAP;AACD,CAVD;AAYA;;;;;;;AAKA,IAAIE,yBAAyB,GAAG,UAASC,OAAT,EAAkB;AAChD,MAAIf,IAAI,GACNe,OAAO,CAACf,IAAR,IACA5E,SAAS,CAAC,oCAAoC8B,IAAI,CAACC,SAAL,CAAe4D,OAAf,CAArC,CAFX;AAGA,MAAIC,GAAG,GAAG,EAAV;;AACA,MACE,CAAChB,IAAI,CAACiB,KAAL,CAAW,UAASC,CAAT,EAAY;AACtB,WAAOA,CAAC,CAACjE,cAAF,CAAiB,MAAjB,CAAP;AACD,GAFA,CADH,EAIE;AACA,UAAM,IAAI7B,SAAJ,CACJ,0DACE8B,IAAI,CAACC,SAAL,CAAe4D,OAAf,CAFE,CAAN;AAID,GATD,MASO;AACLC,IAAAA,GAAG,GAAGP,MAAM,CACVT,IAAI,CAACrC,GAAL,CAAS,UAASuD,CAAT,EAAY;AACnB,aAAOA,CAAC,CAACrF,IAAT;AACD,KAFD,CADU,CAAZ;AAKD;;AACD,SAAO;AAAEsF,IAAAA,WAAW,EAAEH;AAAf,GAAP;AACD,CAtBD;AAwBA;;;;;;;AAKA,IAAII,2BAA2B,GAAG,UAASL,OAAT,EAAkB;AAClD,MAAIf,IAAI,GACNe,OAAO,CAACf,IAAR,IACA5E,SAAS,CAAC,oCAAoC8B,IAAI,CAACC,SAAL,CAAe4D,OAAf,CAArC,CAFX;AAGA,MAAIC,GAAG,GAAG,EAAV;;AACA,MACE,CAAChB,IAAI,CAACiB,KAAL,CAAW,UAASC,CAAT,EAAY;AACtB,WAAOA,CAAC,CAACjE,cAAF,CAAiB,MAAjB,CAAP;AACD,GAFA,CADH,EAIE;AACA,UAAM,IAAI7B,SAAJ,CACJ,0DACE8B,IAAI,CAACC,SAAL,CAAe4D,OAAf,CAFE,CAAN;AAID,GATD,MASO;AACLC,IAAAA,GAAG,GAAGP,MAAM,CACVT,IAAI,CAACrC,GAAL,CAAS,UAASuD,CAAT,EAAY;AACnB,aAAOA,CAAC,CAACrF,IAAT;AACD,KAFD,CADU,CAAZ;AAKD;;AACD,SAAO;AAAEwF,IAAAA,MAAM,EAAEL,GAAG,CAAC,CAAD;AAAb,GAAP;AACD,CAtBD;AAwBA;;;;;;AAIA,IAAIM,KAAK,GAAG,UAASC,OAAT,EAAkB;AAC5B3C,EAAAA,WAAW,CAAC2C,OAAD,EAAU,QAAV,EAAoB,SAApB,CAAX;AACA,SACE,MACAA,OADA,GAEA,GAFA,GAGApB,KAAK,CAACqB,SAAN,CAAgB/E,KAAhB,CACGgF,IADH,CACQC,SADR,EACmB,CADnB,EAEG/D,GAFH,CAEOT,IAAI,CAACC,SAFZ,EAGGwE,IAHH,CAGQ,GAHR,CAHA,GAOA,GARF;AAUD,CAZD;AAcA;;;;;;;;;;;;AAUA,IAAIjD,MAAM,GAAG,UAASkD,MAAT,EAAiBC,OAAjB,EAA0BC,QAA1B,EAAoCC,QAApC,EAA8CC,YAA9C,EAA4DC,GAA5D,EAAiE;AAC5ErD,EAAAA,WAAW,CAACgD,MAAD,EAAS,QAAT,EAAmB,QAAnB,CAAX;AACAhD,EAAAA,WAAW,CAACiD,OAAD,EAAU,QAAV,EAAoB,SAApB,CAAX;AACAjD,EAAAA,WAAW,CAACkD,QAAD,EAAW,QAAX,EAAqB,UAArB,CAAX;AACAlD,EAAAA,WAAW,CAACmD,QAAD,EAAW,QAAX,EAAqB,UAArB,CAAX;AACAnD,EAAAA,WAAW,CAACoD,YAAD,EAAe,QAAf,EAAyB,cAAzB,CAAX;AACApD,EAAAA,WAAW,CAACqD,GAAD,EAAO,QAAP,EAAiB,KAAjB,CAAX;AACA,SAAO;AACLD,IAAAA,YAAY,EAAEA,YADT;AAELC,IAAAA,GAAG,EAAEA,GAFA;AAGLF,IAAAA,QAAQ,EAAEA,QAHL;AAILF,IAAAA,OAAO,EAAEA,OAJJ;AAKLC,IAAAA,QAAQ,EAAEA,QALL;AAMLF,IAAAA,MAAM,EAAEA;AANH,GAAP;AAQD,CAfD;AAiBA;;;;;AAGA,IAAIM,KAAK,GAAG,UAAS7C,GAAT,EAAc;AACxB,SAAO;AACL8C,IAAAA,OAAO,EAAE;AACP,sBAAgB;AADT,KADJ;AAILC,IAAAA,MAAM,EAAE,MAJH;AAKLC,IAAAA,IAAI,EAAEnF,IAAI,CAACC,SAAL,CAAekC,GAAf;AALD,GAAP;AAOD,CARD;AAUA;;;;;AAGA,IAAIiD,QAAQ,GAAG,gBAAgBC,GAAhB,EAAqB;AAClC,QAAMC,MAAM,GAAG,MAAMD,GAArB;AACA,QAAME,GAAG,GAAG,MAAMD,MAAlB;;AACA,MAAIC,GAAG,CAACC,EAAR,EAAW;AACR,UAAMC,OAAO,GAAG,MAAMH,MAAM,CAACI,IAAP,EAAtB;AACA,WAAOD,OAAP;AACD,GAHF,MAGQ;AACL,UAAME,OAAO,GAAG,MAAML,MAAM,CAACM,IAAP,EAAtB;AACA,WAAOD,OAAP;AACD;AACH,CAVD;AAYC;;;;;;;;;;;AAWA;;;;;;;;;;;;;;AAcD;;;;;;;;AAMA,MAAME,SAAS,GAAG,gBAAgBC,OAAhB,EAAyBC,OAAzB,EAAkC;AAClD,MAAIR,GAAG,GAAGS,YAAY,CAACF,OAAD,EAAUC,OAAV,CAAtB;AACA,SAAOX,QAAQ,CAACG,GAAD,CAAf;AACD,CAHD;AAKA;;;;;;;;AAOA,MAAMS,YAAY,GAAG,UAASF,OAAT,EAAkBC,OAAlB,EAA0B;AAC7C,MAAI,CAACA,OAAL,EAAe,MAAM,IAAIrG,KAAJ,CAAW,wCAAX,CAAN;AACf,QAAMuG,QAAQ,GAAGtE,OAAO,CAACmE,OAAD,CAAP,CAAiBrF,GAAjB,CAAqB0B,GAAG,IAAI;AAC3C,QAAIA,GAAG,CAACiB,IAAJ,KAAa,MAAjB,EAAyB;AACvB,aAAOf,cAAc,CAAEF,GAAG,CAAClB,QAAN,EAAgBkB,GAAG,CAACjB,KAApB,EAA2BiB,GAAG,CAACG,KAA/B,EAAsCH,GAAG,CAACI,MAA1C,EACEJ,GAAG,CAACK,QADN,EACgBL,GAAG,CAACM,IADpB,EAC0BN,GAAG,CAACb,OAD9B,EACuCa,GAAG,CAACZ,IAD3C,EAEEY,GAAG,CAACV,SAFN,CAArB;AAGD,KAJD,MAIO;AACL,aAAOT,cAAc,CAAEmB,GAAG,CAAClB,QAAN,EAAgBkB,GAAG,CAACjB,KAApB,EAA2BiB,GAAG,CAACd,QAA/B,EACEc,GAAG,CAACb,OADN,EACea,GAAG,CAACZ,IADnB,EACyBY,GAAG,CAACV,SAD7B,CAArB;AAED;AACF,GATgB,CAAjB;AAUA,SAAO5D,KAAK,CAAE,GAAEkI,OAAQ,cAAZ,EAA2Bf,KAAK,CAACnC,YAAY,CAACoD,QAAD,CAAb,CAAhC,CAAZ;AACD,CAbD;AAeA;;;;;;;AAOA;;;;;;;;AAOA,MAAMC,QAAQ,GAAG,gBAAgBC,MAAhB,EAAwBJ,OAAxB,EAAiC;AAChD,MAAIR,GAAG,GAAGa,WAAW,CAACD,MAAD,EAASJ,OAAT,CAArB;AACA,SAAOX,QAAQ,CAACG,GAAD,CAAf;AACD,CAHD;AAIA;;;;;;;;AAOA,MAAMa,WAAW,GAAG,UAASD,MAAT,EAAiBJ,OAAjB,EAAyB;AAC3C,MAAI,CAACA,OAAL,EAAe,MAAM,IAAIrG,KAAJ,CAAW,uCAAX,CAAN;AACfgC,EAAAA,WAAW,CAACyE,MAAM,CAACE,aAAR,EAAuB,QAAvB,EAAiC,eAAjC,CAAX;AACA3E,EAAAA,WAAW,CAACyE,MAAM,CAACG,UAAR,EAAoB,QAApB,EAA8B,YAA9B,CAAX;AACA,SAAOzI,KAAK,CAAE,GAAEkI,OAAQ,MAAZ,EAAmBf,KAAK,CAACmB,MAAD,CAAxB,CAAZ;AACD,CALD;AAOA;;;;;;;;AAOA,MAAMI,UAAU,GAAG,gBAAgBC,QAAhB,EAA0BT,OAA1B,EAAmC;AACpD,MAAIR,GAAG,GAAGkB,aAAa,CAACD,QAAD,EAAWT,OAAX,CAAvB;AACA,SAAOX,QAAQ,CAACG,GAAD,CAAf;AACD,CAHD;AAIA;;;;;;;;AAOA,MAAMkB,aAAa,GAAG,UAASD,QAAT,EAAmBT,OAAnB,EAA4B;AAChD,MAAI,CAACA,OAAL,EAAe,MAAM,IAAIrG,KAAJ,CAAW,yCAAX,CAAN;AACf,QAAM;AAACuB,IAAAA,QAAD;AAAWC,IAAAA,KAAX;AAAkBG,IAAAA,QAAlB;AAA4BC,IAAAA,OAA5B;AAAqCC,IAAAA,IAArC;AAA2CE,IAAAA;AAA3C,MAAwD+E,QAA9D;AACA,QAAMrE,GAAG,GAAGnB,cAAc,CAACC,QAAD,EAAWC,KAAX,EAAkBG,QAAlB,EAA4BC,OAA5B,EAAqCC,IAArC,EAA2CE,SAA3C,CAA1B;AACA,SAAO5D,KAAK,CAAE,GAAEkI,OAAQ,eAAZ,EAA4Bf,KAAK,CAAC7C,GAAD,CAAjC,CAAZ;AACD,CALD;AAOA;;;;;;;;AAOA,MAAMuE,SAAS,GAAG,gBAAgBC,OAAhB,EAAyBZ,OAAzB,EAAkC;AAClD,MAAIR,GAAG,GAAGqB,YAAY,CAACD,OAAD,EAAUZ,OAAV,CAAtB;AACA,SAAOX,QAAQ,CAACG,GAAD,CAAf;AACD,CAHD;AAKA;;;;;;;;AAOA,MAAMqB,YAAY,GAAG,UAASD,OAAT,EAAkBZ,OAAlB,EAA2B;AAC9C,MAAI,CAACA,OAAL,EAAe,MAAM,IAAIrG,KAAJ,CAAW,wCAAX,CAAN;AACf,SAAO7B,KAAK,CAAE,GAAEkI,OAAQ,cAAZ,EAA2Bf,KAAK,CAAC2B,OAAD,CAAhC,CAAZ;AACD,CAHD;AAKA;;;;;;;;AAOA,MAAME,WAAW,GAAG,gBAAgBC,SAAhB,EAA2Bf,OAA3B,EAAoC;AACtD,MAAIR,GAAG,GAAGwB,cAAc,CAACD,SAAD,EAAYf,OAAZ,CAAxB;AACA,SAAOX,QAAQ,CAACG,GAAD,CAAf;AACD,CAHD;AAKA;;;;;;;;AAOA,MAAMwB,cAAc,GAAG,UAASD,SAAT,EAAoBf,OAApB,EAA6B;AAClD,MAAI,CAACA,OAAL,EAAe,MAAM,IAAIrG,KAAJ,CAAW,0CAAX,CAAN;AACf,SAAO7B,KAAK,CAAE,GAAEkI,OAAQ,gBAAZ,EAA6Bf,KAAK,CAAC8B,SAAD,CAAlC,CAAZ;AACD,CAHD;AAKA;;;;AAIA;;;;;;;;;;AAQA,IAAIE,KAAK,GAAG,UAASC,IAAT,EAAeC,WAAf,EAA4BjJ,IAA5B,EAAkCkJ,IAAI,GAAC,EAAvC,EAA2C;AACrDzF,EAAAA,WAAW,CAACuF,IAAD,EAAO,QAAP,EAAiB,MAAjB,CAAX;AACAvF,EAAAA,WAAW,CAACwF,WAAD,EAAc,QAAd,EAAwB,aAAxB,CAAX;AACAxF,EAAAA,WAAW,CAACzD,IAAD,EAAO,QAAP,EAAiB,oBAAjB,CAAX;AACAyD,EAAAA,WAAW,CAACyF,IAAD,EAAO,QAAP,EAAiB,yBAAjB,CAAX;AACA,SAAO;AACLF,IAAAA,IAAI,EAAEA,IADD;AAELC,IAAAA,WAAW,EAAEA,WAFR;AAGLE,IAAAA,GAAG,EAAE;AACHnJ,MAAAA,IAAI,EAAEA,IADH;AAEHkJ,MAAAA,IAAI,EAAEA;AAFH;AAHA,GAAP;AAQD,CAbD;AAeA;;;;;;;;;;;;AAYA;;;;;;;AAMC,MAAME,UAAU,GAAG,gBAAgBC,UAAhB,EAA4B;AAC7C,MAAI/B,GAAG,GAAGgC,aAAa,CAACD,UAAD,CAAvB;AACA,MAAIE,SAAS,GAAG,MAAMpC,QAAQ,CAACG,GAAD,CAA9B;AACA,SAAOiC,SAAS,CAACrC,IAAjB;AACD,CAJD;AAMD;;;;;;;AAMC,MAAMoC,aAAa,GAAG,UAAUD,UAAV,EAAqB;AACzC,MAAI,CAACA,UAAU,CAACjG,QAAhB,EAA0B,MAAM,IAAI3B,KAAJ,CAAW,2CAAX,CAAN;AAC1B,MAAI,CAAC4H,UAAU,CAACG,IAAhB,EAAsB,MAAM,IAAI/H,KAAJ,CAAW,sCAAX,CAAN;AACtBgC,EAAAA,WAAW,CAAC4F,UAAU,CAACjG,QAAZ,EAAsB,QAAtB,EAAgC,UAAhC,CAAX;AACAK,EAAAA,WAAW,CAAC4F,UAAU,CAACG,IAAZ,EAAkB,QAAlB,EAA4B,MAA5B,CAAX;AACA,MAAIH,UAAU,CAAChG,OAAf,EAAwBI,WAAW,CAAC4F,UAAU,CAAChG,OAAZ,EAAqB,QAArB,EAA+B,SAA/B,CAAX;AACxB,MAAIgG,UAAU,CAAC5C,MAAf,EAAuBhD,WAAW,CAAC4F,UAAU,CAAC5C,MAAZ,EAAoB,QAApB,EAA8B,QAA9B,CAAX;AACvB,MAAI4C,UAAU,CAAC3C,OAAf,EAAwBjD,WAAW,CAAC4F,UAAU,CAAC3C,OAAZ,EAAqB,QAArB,EAA+B,SAA/B,CAAX;AACxB,MAAI2C,UAAU,CAACzC,QAAf,EAAyBnD,WAAW,CAAC4F,UAAU,CAACzC,QAAZ,EAAsB,QAAtB,EAAgC,UAAhC,CAAX;AACzB,MAAIyC,UAAU,CAACpG,KAAf,EAAsBQ,WAAW,CAAC4F,UAAU,CAACpG,KAAZ,EAAmB,QAAnB,EAA6B,OAA7B,CAAX;AACtB,MAAIoG,UAAU,CAACvC,GAAf,EAAoBrD,WAAW,CAAC4F,UAAU,CAACvC,GAAZ,EAAiB,QAAjB,EAA2B,KAA3B,CAAX;AAEpB,QAAM5C,GAAG,GAAG;AACVD,IAAAA,IAAI,EAAEoF,UAAU,CAACjG,QADP;AAEVoG,IAAAA,IAAI,EAAE9F,OAAO,CAAC2F,UAAU,CAACG,IAAZ,CAFH;AAGVxF,IAAAA,IAAI,EAAEqF,UAAU,CAAChG,OAHP;AAIVoD,IAAAA,MAAM,EAAE4C,UAAU,CAAC5C,MAJT;AAKVC,IAAAA,OAAO,EAAE2C,UAAU,CAAC3C,OALV;AAMVE,IAAAA,QAAQ,EAAEyC,UAAU,CAACzC,QANX;AAOV3D,IAAAA,KAAK,EAAEoG,UAAU,CAACpG,KAPR;AAQV6D,IAAAA,GAAG,EAAEuC,UAAU,CAACvC;AARN,GAAZ;AAUA,SAAOlH,KAAK,CAAC,+BAAD,EAAkCmH,KAAK,CAAC7C,GAAD,CAAvC,CAAZ;AACD,CAvBD;AAwBD;;;;;;;;AAMA,MAAMuF,UAAU,GAAG,gBAAgBC,SAAhB,EAA2B5B,OAA3B,EAAoC;AACrD,QAAM5D,GAAG,GAAG;AACV,YAAQ,CAAEwF,SAAF;AADE,GAAZ;AAGA,QAAMC,KAAK,GAAG,MAAM/J,KAAK,CAAE,GAAEkI,OAAQ,cAAZ,EAA2Bf,KAAK,CAAC7C,GAAD,CAAhC,CAAzB;AACA,QAAM0F,EAAE,GAAG,MAAMD,KAAK,CAAClC,IAAN,EAAjB;AACA,SAAOmC,EAAP;AACD,CAPD;;AASAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,MAAM,EAAE;AACNlK,IAAAA,QAAQ,EAAEA,QADJ;AAENQ,IAAAA,QAAQ,EAAEA,QAFJ;AAGNM,IAAAA,eAAe,EAAEA,eAHX;AAIND,IAAAA,IAAI,EAAEA,IAJA;AAKNI,IAAAA,UAAU,EAAEA,UALN;AAMNS,IAAAA,2BAA2B,EAAEA,2BANvB;AAONP,IAAAA,IAAI,EAAEA,IAPA;AAQNa,IAAAA,oBAAoB,EAAEA;AARhB,GADO;AAWfmI,EAAAA,GAAG,EAAE;AACH5F,IAAAA,cAAc,EAAEA,cADb;AAEHrB,IAAAA,cAAc,EAAEA,cAFb;AAGHoB,IAAAA,WAAW,EAAEA,WAHV;AAIHS,IAAAA,YAAY,EAAEA;AAJX,GAXU;AAiBfqF,EAAAA,IAAI,EAAE;AACJ9D,IAAAA,KAAK,EAAEA,KADH;AAEJ5C,IAAAA,MAAM,EAAEA,MAFJ;AAGJwF,IAAAA,KAAK,EAAEA;AAHH,GAjBS;AAsBfmB,EAAAA,MAAM,EAAE;AACNzF,IAAAA,IAAI,EAAE;AACJ0F,MAAAA,aAAa,EAAE9E;AADX,KADA;AAINtB,IAAAA,IAAI,EAAE;AACJoG,MAAAA,aAAa,EAAE/E,iBADX;AAEJgF,MAAAA,kBAAkB,EAAErH,cAFhB;AAGJsH,MAAAA,iBAAiB,EAAE1E,yBAHf;AAIJ2E,MAAAA,mBAAmB,EAAErE;AAJjB;AAJA,GAtBO;AAiCfrG,EAAAA,KAAK,EAAE;AACL2K,IAAAA,IAAI,EAAE3C,SADD;AAEL4C,IAAAA,KAAK,EAAElC,UAFF;AAGLmC,IAAAA,IAAI,EAAEhC,SAHD;AAILvC,IAAAA,MAAM,EAAE0C,WAJH;AAKL8B,IAAAA,GAAG,EAAEzC;AALA,GAjCQ;AAwCf0C,EAAAA,MAAM,EAAE;AACN3J,IAAAA,IAAI,EAAEoI,UADA;AAENK,IAAAA,UAAU,EAAEA;AAFN;AAxCO,CAAjB","sourcesContent":["/** pact-lang-api.js\n * Exports functions to support Pact API calls.\n * Author: Will Martino, Hee Kyun Yun, Stuart Popejoy\n * Supports: Pact API 3.0 v1\n */\n\nconst blake = require(\"blakejs\");\nconst nacl = require(\"tweetnacl\");\nconst base64url = require(\"base64-url\");\nconst fetch = require(\"node-fetch\");\n\n/**\n * Convert binary to hex.\n * @param s {Uint8Array} - binary value\n * @return {string} hex string\n */\nvar binToHex = function(s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== \"Uint8Array\") {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n\n  return Buffer.from(s).toString(\"hex\");\n};\n\n/**\n * Convert hex string to binary.\n * @param s {string} - hex string\n * @return {Uint8Array} binary value\n */\nvar hexToBin = function(h) {\n  if (typeof h !== \"string\") {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n  return new Uint8Array(Buffer.from(h, \"hex\"));\n};\n\n/**\n * Perform blake2b256 hashing.\n */\nvar hashBin = function(s) {\n  return blake.blake2b(s, null, 32);\n};\n\n/**\n * Perform blake2b256 hashing, encoded as unescaped base64url.\n */\nvar hash = function(s) {\n  return base64UrlEncode(hashBin(s));\n};\n\n/**\n * Hash string as unescaped base64url.\n */\nvar base64UrlEncode = function(s) {\n  return base64url.escape(base64url.encode(s));\n};\n\n/**\n * Generate a random ED25519 keypair.\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\nvar genKeyPair = function() {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return { publicKey: pubKey, secretKey: secKey };\n};\n\n/**\n * Generate a deterministic ED25519 keypair from a given Kadena secretKey\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\nvar restoreKeyPairFromSecretKey = function(seed) {\n  if (!seed)  throw new Error(`seed for KeyPair generation not provided`);\n  if (seed.length !== 64) throw new Error('Seed for KeyPair generation has bad size');\n  var seedForNacl = hexToBin(seed);\n  var kp = nacl.sign.keyPair.fromSeed(seedForNacl);\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return { publicKey: pubKey, secretKey: secKey };\n};\n\nvar toTweetNaclSecretKey = function(keyPair) {\n  if (\n    !keyPair.hasOwnProperty(\"publicKey\") ||\n    !keyPair.hasOwnProperty(\"secretKey\")\n  ) {\n    throw new TypeError(\n      \"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" +\n        JSON.stringify(keyPair)\n    );\n  }\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n\n/**\n * Attach signature to hashed data\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {Array} of \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key values.\n */\nvar attachSig = function(msg, kpArray) {\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n  if (kpArray.length === 0 ) {\n   return [{hash: hsh, sig: undefined}];\n  } else {\n    return kpArray.map(kp => {\n      if (\n        (kp.hasOwnProperty(\"publicKey\") && kp.publicKey) &&\n        (kp.hasOwnProperty(\"secretKey\") && kp.secretKey)) {\n        return sign(msg, kp);\n      } else {\n        return {\n          hash: hsh,\n          sig: undefined,\n          publicKey: kp.publicKey\n        };\n      }\n    })\n  }\n};\n\n/**\n * Sign data using key pair.\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {object} with \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key value.\n */\nvar sign = function(msg, keyPair) {\n  if (\n    !keyPair.hasOwnProperty(\"publicKey\") ||\n    !keyPair.hasOwnProperty(\"secretKey\")\n  ) {\n    throw new TypeError(\n      \"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" +\n        JSON.stringify(keyPair)\n    );\n  }\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return { hash: hsh, sig: binToHex(sigBin), pubKey: keyPair.publicKey };\n};\n\nvar pullSig = function(s) {\n  if (!s.hasOwnProperty(\"sig\")) {\n    throw new TypeError(\n      \"Expected to find keys of name 'sig' in \" + JSON.stringify(s)\n    );\n  }\n  return { sig: s.sig };\n};\n\nvar pullAndCheckHashs = function(sigs) {\n  var hsh = sigs[0].hash;\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error(\n        \"Sigs for different hashes found: \" + JSON.stringify(sigs)\n      );\n    }\n  }\n  return hsh;\n};\n\n/**\n * Prepare an ExecMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param pactCode {string} - pact code to execute - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API command for send or local use.\n */\nvar prepareExecCmd = function(keyPairs=[], nonce=new Date().toISOString(), pactCode,\n                              envData, meta=mkMeta(\"\",\"\",0,0,0,0), networkId=null) {\n\n  enforceType(nonce, \"string\", \"nonce\");\n  enforceType(pactCode, \"string\", \"pactCode\");\n  var kpArray = asArray(keyPairs);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      exec: {\n        data: envData || {},\n        code: pactCode\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = attachSig(cmd, kpArray);\n  return mkSingleCmd(sigs, cmd);\n};\n\n/**\n * Prepare an ContMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param step {number} - integer index of step to execute in defpact body - required\n * @param proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n * @param rollback {bool} - Indicates if this continuation is a rollback/cancel- required\n * @param pactId {string} - identifies the already-begun Pact execution that this is continuing - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API Cont command for send or local use.\n */\nvar prepareContCmd = function(keyPairs=[], nonce=new Date().toISOString(),\n                              proof, pactId, rollback, step, envData,\n                              meta=mkMeta(\"\",\"\",0,0,0,0), networkId=null) {\n\n  enforceType(nonce, \"string\", \"nonce\");\n  var kpArray = asArray(keyPairs);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      cont: {\n        proof: proof || null,\n        pactId: pactId,\n        rollback: rollback,\n        step: step,\n        data: envData || {},\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = attachSig(cmd, kpArray);\n  return mkSingleCmd(sigs, cmd);\n};\n\n/**\n * Makes a single command given signed data.\n * @param sigs {array} - array of signature objects, see 'sign'\n * @param cmd {string} - stringified JSON blob used to create hash\n * @return valid Pact API command for send or local use.\n */\nvar mkSingleCmd = function(sigs, cmd) {\n  enforceArray(sigs, \"sigs\");\n  enforceType(cmd, \"string\", \"cmd\");\n  return {\n    hash: pullAndCheckHashs(sigs),\n    sigs: sigs.filter(sig => sig.sig).map(pullSig),\n    cmd: cmd\n  };\n};\n\n/**\n * Makes outer wrapper for a 'send' endpoint.\n * @param {array or object} cmds - one or an array of commands, see mkSingleCmd\n */\nvar mkPublicSend = function(cmds) {\n  return { cmds: asArray(cmds) };\n};\n\n/**\n * Make an ED25519 \"signer\" array element for inclusion in a Pact payload.\n * @param {object} kp - a ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @return {object} an object with pubKey, addr and scheme fields.\n */\nvar mkSigner = function(kp) {\n  if (kp.clist) {\n    return {\n      clist: asArray(kp.clist),\n      pubKey: kp.publicKey\n    }\n  } else {\n    return {pubKey: kp.publicKey}\n  }\n};\n\nvar asArray = function(singleOrArray) {\n  if (Array.isArray(singleOrArray)) {\n    return singleOrArray;\n  } else {\n    return [singleOrArray];\n  }\n};\n\nvar enforceType = function(val, type, msg) {\n  if (typeof val !== type) {\n    throw new TypeError(\n      msg + \" must be a \" + type + \": \" + JSON.stringify(val)\n    );\n  }\n};\n\nvar enforceArray = function(val, msg) {\n  if (!Array.isArray(val)) {\n    throw new TypeError(msg + \" must be an array: \" + JSON.stringify(val));\n  }\n};\n\n/**\n * Make a full 'send' endpoint exec command. See 'prepareExecCmd' for parameters.\n */\nvar simpleExecCommand = function(keyPairs, nonce, pactCode, envData, meta, networkId) {\n  return mkPublicSend(prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId));\n};\n\n/**\n * Make a full 'send' endpoint cont command. See 'prepareContCmd' for parameters.\n */\nvar simpleContCommand = function(keyPairs, nonce, step, pactId, rollback, envData, meta, proof, networkId) {\n  return mkPublicSend(prepareContCmd(keyPairs, nonce, proof, pactId, rollback, step, envData, meta, networkId));\n};\n\nvar unique = function(arr) {\n  var n = {},\n    r = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n  return r;\n};\n\n/**\n * Given an exec 'send' message, prepare a message for 'poll' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'\n * @return {object} with \"requestKeys\" for polling.\n */\nvar simplePollRequestFromExec = function(execMsg) {\n  var cmds =\n    execMsg.cmds ||\n    TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n  if (\n    !cmds.every(function(v) {\n      return v.hasOwnProperty(\"hash\");\n    })\n  ) {\n    throw new TypeError(\n      'maleformed object, expected \"hash\" key in every cmd: ' +\n        JSON.stringify(execMsg)\n    );\n  } else {\n    rks = unique(\n      cmds.map(function(v) {\n        return v.hash;\n      })\n    );\n  }\n  return { requestKeys: rks };\n};\n\n/**\n * Given an exec 'send' message, prepare a message for 'listen' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'. Only takes first element.\n * @return {object} with \"requestKey\" for polling.\n */\nvar simpleListenRequestFromExec = function(execMsg) {\n  var cmds =\n    execMsg.cmds ||\n    TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n  if (\n    !cmds.every(function(v) {\n      return v.hasOwnProperty(\"hash\");\n    })\n  ) {\n    throw new TypeError(\n      'maleformed object, expected \"hash\" key in every cmd: ' +\n        JSON.stringify(execMsg)\n    );\n  } else {\n    rks = unique(\n      cmds.map(function(v) {\n        return v.hash;\n      })\n    );\n  }\n  return { listen: rks[0] };\n};\n\n/**\n * Variadic function to form a lisp s-expression application.\n * Encases arguments in parens and intercalates with a space.\n */\nvar mkExp = function(pgmName) {\n  enforceType(pgmName, \"string\", \"pgmName\");\n  return (\n    \"(\" +\n    pgmName +\n    \" \" +\n    Array.prototype.slice\n      .call(arguments, 1)\n      .map(JSON.stringify)\n      .join(\" \") +\n    \")\"\n  );\n};\n\n/**\n * Prepare a chainweb-style public meta payload.\n * @param sender {string} gas account\n * @param chainId {string} chain identifier\n * @param gasPrice {number} desired gas price\n * @param gasLimit {number} desired gas limit\n * @param creationTime {number} desired tx's time created in UNIX epoch time as seconds\n * @param ttl {number} desired tx's time to live as seconds\n * @return {object} of arguments, type-checked and properly named.\n */\nvar mkMeta = function(sender, chainId, gasPrice, gasLimit, creationTime, ttl) {\n  enforceType(sender, \"string\", \"sender\");\n  enforceType(chainId, \"string\", \"chainId\");\n  enforceType(gasPrice, \"number\", \"gasPrice\");\n  enforceType(gasLimit, \"number\", \"gasLimit\");\n  enforceType(creationTime, \"number\", \"creationTime\");\n  enforceType(ttl,  \"number\", \"ttl\");\n  return {\n    creationTime: creationTime,\n    ttl: ttl,\n    gasLimit: gasLimit,\n    chainId: chainId,\n    gasPrice: gasPrice,\n    sender: sender\n  };\n};\n\n/**\n * Formats ExecCmd into api request object\n */\nvar mkReq = function(cmd) {\n  return {\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    body: JSON.stringify(cmd)\n  };\n};\n\n/**\n * Parses raw response from server into JSON or TEXT\n */\nvar parseRes = async function (raw) {\n  const rawRes = await raw;\n  const res = await rawRes;\n  if (res.ok){\n     const resJSON = await rawRes.json();\n     return resJSON;\n   } else {\n     const resTEXT = await rawRes.text();\n     return resTEXT;\n   }\n};\n\n /**\n  * An execCmd Object to Execute in send or local.\n  * @typedef {Object} cmd to `/send` endpoint\n  * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n  * @property pactCode {string} - pact code to execute in \"exec\" command - required for \"exec\"\n  * @property nonce {string} - nonce value to ensure unique hash - default to current time\n  * @property envData {object} - JSON of data in command - not required\n  * @property meta {object} - public meta information, see mkMeta\n  * @property networkId {object} network identifier of where the cmd is executed.\n  */\n\n /**\n  * A contCmd to Execute in send\n  * @typedef {Object} cmd to `/send` endpoint\n  * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n  * @property pactId {string} - pactId the cont command - required for \"cont\"\n  * @property nonce {string} - nonce value to ensure unique hash - default to current time\n  * @property step {number} - the step of the mutli-step transaction - required for \"cont\"\n  * @property proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n  * @property rollback {bool} - Indicates if this continuation is a rollback/cancel - required for \"cont\"\n  * @property envData {object} - JSON of data in command - not required\n  * @property meta {object} - public meta information, see mkMeta\n  * @property networkId {object} network identifier of where the cmd is executed.\n  */\n\n/**\n* Sends Pact command to a running Pact server and retrieves tx result.\n* @param {[execCmd or contCmd] or execCmd or contCmd} cmd or a list of cmds to execute\n* @param {string} apiHost host running Pact server\n* @return {object} Request key of the tx received from pact server.\n*/\nconst fetchSend = async function (sendCmd, apiHost) {\n  let res = fetchSendRaw(sendCmd, apiHost);\n  return parseRes(res);\n}\n\n/**\n* Sends Pact command to a running Pact server and retrieves raw response.\n* @param {[execCmd or contCmd] or execCmd or contCmd} cmd or a list of cmds to execute\n* @param {string} apiHost host running Pact server\n* @return {Promise} Raw Response from Pact Server\n*/\n\nconst fetchSendRaw = function(sendCmd, apiHost){\n  if (!apiHost)  throw new Error(`Pact.fetch.send(): No apiHost provided`);\n  const sendCmds = asArray(sendCmd).map(cmd => {\n    if (cmd.type === \"cont\") {\n      return prepareContCmd( cmd.keyPairs, cmd.nonce, cmd.proof, cmd.pactId,\n                             cmd.rollback, cmd.step, cmd.envData, cmd.meta,\n                             cmd.networkId )\n    } else {\n      return prepareExecCmd( cmd.keyPairs, cmd.nonce, cmd.pactCode,\n                             cmd.envData, cmd.meta, cmd.networkId )\n    }\n  })\n  return fetch(`${apiHost}/api/v1/send`, mkReq(mkPublicSend(sendCmds)));\n};\n\n/**\n * A SPV Command Object to Execute in Pact Server.\n * @typedef {Object} spvCmd\n * @property requestKey {string} pactId of the cross-chain transaction\n * @property targetChainId {string} chainId of target chain of the cross-chain transaction\n */\n\n/**\n * Sends request to /spv and retrieves SPV proof.\n * @param {spvCmd} spvCmd see spvCmd\n * @param {string} apiHost host running Pact server\n * @return {string} SPV proof received from Pact server.\n */\n\nconst fetchSPV = async function (spvCmd, apiHost) {\n  let res = fetchSPVRaw(spvCmd, apiHost);\n  return parseRes(res);\n}\n/**\n * Sends request to /spv and retrieves raw response.\n * @param {spvCmd} spvCmd see spvCmd\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\nconst fetchSPVRaw = function(spvCmd, apiHost){\n  if (!apiHost)  throw new Error(`Pact.fetch.spv(): No apiHost provided`);\n  enforceType(spvCmd.targetChainId, \"string\", \"targetChainId\");\n  enforceType(spvCmd.requestKey, \"string\", \"requestKey\");\n  return fetch(`${apiHost}/spv`, mkReq(spvCmd));\n};\n\n/**\n * Sends Local Pact command to a local Pact server and retrieves local tx result.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {object} tx result received from pact server.\n */\n\nconst fetchLocal = async function (localCmd, apiHost) {\n  let res = fetchLocalRaw(localCmd, apiHost);\n  return parseRes(res);\n}\n/**\n * Sends Local Pact command to a local Pact server and retrieves raw response.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\nconst fetchLocalRaw = function(localCmd, apiHost) {\n  if (!apiHost)  throw new Error(`Pact.fetch.local(): No apiHost provided`);\n  const {keyPairs, nonce, pactCode, envData, meta, networkId} = localCmd\n  const cmd = prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId);\n  return fetch(`${apiHost}/api/v1/local`, mkReq(cmd));\n};\n\n/**\n * Poll result of Pact command on a Pact server and retrieve tx result.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {object} Array of tx request keys and tx results from pact server.\n */\n\nconst fetchPoll = async function (pollCmd, apiHost) {\n  let res = fetchPollRaw(pollCmd, apiHost);\n  return parseRes(res);\n}\n\n/**\n * Poll result of Pact command on a Pact server and retrieves raw response.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\nconst fetchPollRaw = function(pollCmd, apiHost) {\n  if (!apiHost)  throw new Error(`Pact.fetch.poll(): No apiHost provided`);\n  return fetch(`${apiHost}/api/v1/poll`, mkReq(pollCmd));\n};\n\n/**\n * Listen for result of Pact command on a Pact server and retrieve tx result.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {object} Object containing tx result from pact server\n */\n\nconst fetchListen = async function (listenCmd, apiHost) {\n  let res = fetchListenRaw(listenCmd, apiHost);\n  return parseRes(res);\n}\n\n/**\n * Listen for result of Pact command on a Pact server and retrieves raw response.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {Promise} Raw Response from Pact Server\n */\n\nconst fetchListenRaw = function(listenCmd, apiHost) {\n  if (!apiHost)  throw new Error(`Pact.fetch.listen(): No apiHost provided`);\n  return fetch(`${apiHost}/api/v1/listen`, mkReq(listenCmd));\n};\n\n/**\n  Signing API functions to interact with Chainweaver wallet (https://github.com/kadena-io/chainweaver) and its signing API.\n */\n\n/**\n * Prepares a capability object to be signed with keyPairs using signing API.\n * @param role {string} role of the pact capability\n * @param description {string} description of the pact capability\n * @param name {string} name of pact capability to be signed\n * @param args {array} array of arguments used in pact capability, default to empty array.\n * @return {object} A properly formatted cap object required in signingCmd\n */\nvar mkCap = function(role, description, name, args=[]) {\n  enforceType(role, \"string\", \"role\");\n  enforceType(description, \"string\", \"description\");\n  enforceType(name, \"string\", \"name of capability\");\n  enforceType(args, \"object\", \"arguments to capability\");\n  return {\n    role: role,\n    description: description,\n    cap: {\n      name: name,\n      args: args\n    }\n  };\n};\n\n/**\n * A signingCmd Object to send to signing API\n * @typedef {Object} signingCmd - cmd to send to signing API\n * @property pactCode {string} - Pact code to execute - required\n * @property caps {array or object} - Pact capability to be signed, see mkCap - required\n * @property envData {object} - JSON of data in command - optional\n * @property sender {string} - sender field in meta, see mkMeta - optional\n * @property chainId {string} - chainId field in meta, see mkMeta - optional\n * @property gasLimit {number} - gasLimit field in meta, see mkMeta - optional\n * @property nonce {string} - nonce value for ensuring unique hash - optional\n **/\n\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves a signed Pact Command.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n\n const signWallet = async function (signingCmd) {\n   let res = signWalletRaw(signingCmd);\n   let resParsed = await parseRes(res)\n   return resParsed.body;\n }\n\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves raw response.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n\n const signWalletRaw = function (signingCmd){\n   if (!signingCmd.pactCode) throw new Error(`Pact.wallet.sign(): No Pact Code provided`);\n   if (!signingCmd.caps) throw new Error(`Pact.wallet.sign(): No Caps provided`);\n   enforceType(signingCmd.pactCode, \"string\", \"pactCode\");\n   enforceType(signingCmd.caps, \"object\", \"caps\");\n   if (signingCmd.envData) enforceType(signingCmd.envData, \"object\", \"envData\");\n   if (signingCmd.sender) enforceType(signingCmd.sender, \"string\", \"sender\");\n   if (signingCmd.chainId) enforceType(signingCmd.chainId, \"string\", \"chainId\");\n   if (signingCmd.gasLimit) enforceType(signingCmd.gasLimit, \"number\", \"gasLimit\");\n   if (signingCmd.nonce) enforceType(signingCmd.nonce, \"string\", \"nonce\");\n   if (signingCmd.ttl) enforceType(signingCmd.ttl, \"number\", \"ttl\");\n\n   const cmd = {\n     code: signingCmd.pactCode,\n     caps: asArray(signingCmd.caps),\n     data: signingCmd.envData,\n     sender: signingCmd.sender,\n     chainId: signingCmd.chainId,\n     gasLimit: signingCmd.gasLimit,\n     nonce: signingCmd.nonce,\n     ttl: signingCmd.ttl\n   }\n   return fetch('http://127.0.0.1:9467/v1/sign', mkReq(cmd))\n }\n/**\n * Sends a signed Pact ExecCmd to a running Pact server and retrieves tx result.\n * @param {signedCmd} valid pact API command for send or local use.\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\nconst sendSigned = async function (signedCmd, apiHost) {\n  const cmd = {\n    \"cmds\": [ signedCmd ]\n  }\n  const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n}\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    base64UrlEncode: base64UrlEncode,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    restoreKeyPairFromSecretKey: restoreKeyPairFromSecretKey,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    prepareContCmd: prepareContCmd,\n    prepareExecCmd: prepareExecCmd,\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp,\n    mkMeta: mkMeta,\n    mkCap: mkCap\n  },\n  simple: {\n    cont: {\n      createCommand: simpleContCommand\n    },\n    exec: {\n      createCommand: simpleExecCommand,\n      createLocalCommand: prepareExecCmd,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  },\n  fetch: {\n    send: fetchSend,\n    local: fetchLocal,\n    poll: fetchPoll,\n    listen: fetchListen,\n    spv: fetchSPV\n  },\n  wallet: {\n    sign: signWallet,\n    sendSigned: sendSigned\n  }\n};\n"]},"metadata":{},"sourceType":"script"}